// TODO: #![deny(missing_docs)]
#![warn(clippy::pedantic)]

pub mod access;
#[macro_use]
pub mod partial;
pub mod presence;

#[cfg(test)]
mod tests {
    #![allow(dead_code)]

    use crate::{access::Access, presence::Present};

    partial! {person {
        name: String,
        age: u8,
        height: f32,
    }}

    impl<F: person::Fields<name = Present>> person::Struct<F> {
        fn shout_name(&self) -> String {
            let uppercase = self.name.to_uppercase();
            match self.age.get() {
                Some(age) => format!("{uppercase} ({age})"),
                None => uppercase,
            }
        }
    }

    impl<F: person::Fields<name = Present, age = Present>> person::Struct<F> {
        fn say_hello(&self) -> String {
            format!(
                "Hi! I'm {name} and I'm {age} years old",
                name = self.name,
                age = self.age
            )
        }
    }

    #[test]
    fn methods_example() {
        // we don't know John's age yet
        let john = person::Struct::empty().name("John".into());

        // we can call shout_name, but not say_hello
        assert_eq!(john.shout_name(), "JOHN");

        let john = john.age(26);

        // now that we know John's age, we can call say_hello
        assert_eq!(john.say_hello(), "Hi! I'm John and I'm 26 years old");

        // the behaviour of shout_name changes since john has an age
        assert_eq!(john.shout_name(), "JOHN (26)");
    }

    #[test]
    fn test_merge() {
        let josef = person::Struct::empty().name("Josef".into());

        let josef = josef.merge(person::Struct::empty().age(37));
        assert_eq!(josef.name, "Josef");
        assert_eq!(josef.age, 37);
        let josefine = josef.merge(person::Struct::empty().name("Josefine".into()));
        assert_eq!(josefine.name, "Josefine");
        assert_eq!(josefine.age, 37);
    }

    // Will be generated by a future version of the partial macro
    mod with {
        use crate::presence::Present;

        use super::person::{Fields, Struct};

        use std::marker::PhantomData;

        pub struct Name<F: Fields>(PhantomData<F>);
        impl<F: Fields> Fields for Name<F> {
            type name = Present;
            type age = F::age;
            type height = F::height;
        }

        pub struct Age<F: Fields>(PhantomData<F>);
        impl<F: Fields> Fields for Age<F> {
            type name = F::name;
            type age = Present;
            type height = F::height;
        }

        pub struct Height<F: Fields>(PhantomData<F>);
        impl<F: Fields> Fields for Height<F> {
            type name = F::name;
            type age = F::age;
            type height = Present;
        }

        impl<F: Fields> Struct<F> {
            pub fn name(self, name: String) -> Struct<Name<F>> {
                Struct {
                    name,
                    age: self.age,
                    height: self.height,
                }
            }

            pub fn age(self, age: u8) -> Struct<Age<F>> {
                Struct {
                    name: self.name,
                    age,
                    height: self.height,
                }
            }

            pub fn height(self, height: f32) -> Struct<Height<F>> {
                Struct {
                    name: self.name,
                    age: self.age,
                    height,
                }
            }
        }
    }
}
