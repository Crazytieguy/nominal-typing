// TODO: #![deny(missing_docs)]
#![warn(clippy::pedantic)]

mod access;
#[macro_use]
mod partial;

#[cfg(test)]
mod tests {
    #![allow(dead_code)]

    use crate::access::Access;
    use std::marker::PhantomData;

    partial! {person {
        name: String,
        age: u8,
    }}

    // All fields are present by default
    impl person::Struct {
        fn say_hello(&self) -> String {
            format!("Hi! I'm {} and I'm {} years old", self.name, self.age)
        }
    }

    // Any person that has at least a name
    trait Named: person::has::name {
        fn shout_name(&self) -> String {
            // this borrows Self as Person, so that the fields can be accessed
            let borrowed = self.borrow();
            let uppercase = borrowed.name.to_uppercase();
            match borrowed.age.get() {
                Some(age) => format!("{uppercase} ({age})"),
                None => uppercase,
            }
        }
    }
    impl<T: person::has::name> Named for T {}

    #[test]
    fn case() {
        let p = person::Struct {
            name: "Yoav".to_string(),
            age: PhantomData,
        };
        assert_eq!(p.shout_name(), "YOAV");
        let p = person::Struct {
            age: 26,
            name: p.name,
        };
        assert_eq!(p.shout_name(), "YOAV (26)");
        assert_eq!(p.say_hello(), "Hi! I'm Yoav and I'm 26 years old");
        assert_eq!(p.age, 26);
        assert_eq!(p.name, "Yoav");
    }

    // This will be generated by a future version of the partial! macro
    mod with {
        #![allow(non_camel_case_types)]
        #![allow(type_alias_bounds)]

        pub type age<T: super::person::Interface> = super::person::Struct<T::name, u8>;
    }

    fn with_age<T: person::Interface>(person: T, age: u8) -> with::age<T> {
        person::Struct {
            age,
            name: person.into().name,
        }
    }
}
